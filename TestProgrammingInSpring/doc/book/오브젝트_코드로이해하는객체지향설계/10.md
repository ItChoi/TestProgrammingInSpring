### 상속과 코드 재사용
- 객체지향 프로그래밍의 장점 중 하나는 코드를 재사용하는 것이다. 객체지향 언어에서 코드를 재사용하기 위해서는 코드가 작성된 클래스를 새로운 클래스에 추가하는 것이다. 재사용의 양면에는 중복 방지를 위함이 있는데, 중복 코드의 문제점을 먼저 살펴보자.

#### 상속과 중복코드
- 중복 코드는 시스템과 개발자에게 혼동을 준다. 몇 가지 이유를 살펴보자.
    - DRY 원칙
      - DRY: Don't Repeat Yourself -> 동일 지식을 중복하지 마라, Once and Only Once 원칙 및 Single-Point-Control 원칙이라고도 부른다.
      - 중복 코드는 변경을 방해한다. 즉, 우리개 개발을 할 때 비즈니스 관련 지식을 코드로 표현하게 되는데, 이 지식들은 항상 변한다.
      - 중복 코드는 수정과 테스트 비용을 증가시키고 가독성을 낮춘다.
      - 중복 여부 판단 기준은 **변경**이다. 요구사항 변경 시 두 코드를 같이 변경해야 한다면 중복이다. 모양이 유사하다고 해서 중복은 아니지만, 그렇다고 좋은 코드라고 볼 수는 없다. 중복의 징후로 보고 코드를 다시 살펴보는 것이 필요할 거 같다.
    <br/>

- 예를 들어 핸드폰 정책을 사용하다가, 심야 할인 정책이 생겼다고 했을 때, 기존의 코드를 기반으로 심야 할인 정책의 코드를 새로 추가하면, 요구 사항을 짧은 시간 안에 구현 가능하지만, 이 대가로 지불해야 하는 비용이 상당히 클 수도 있다. 앞에서 말했지만, 비즈니스 관련 지식은 항상 변경될 가능성이 있기 때문에, 중복 코드가 추가될 수록 새로운 중복 코드를 발생시키고, 코드의 일관성이 무너질 가능성 (중복 코드마다 다른 로직 추가), 일부 중독 코드에 추가해야할 코드를 넣지 않고 배포했을 때 발생하는 에러 등 중복 코드를 제거해야하는 이유는 굉장히 많다.

#### 타입 코드 사용하기.
- 두 클래스 사이의 중복을 제거하는 방법 중 하나는 두 개를 하나의 클래스로 합치고 타입 코드 추가 후 조건에 따라 로직을 분기시키는 것이다. 
- 그러나 타입 코드를 사용하는 클래스는 낮은 응집도와 높은 결합도라는 문제가 생긴다.
- 객체지향 프로그래밍에서는 타입 코드를 사용하지 않고 중복 코드 관리하는 효과적인 방법 제공

##### 상속을 이용해서 중복 코드 제거하기
- 상속 사용시 부모 클래스의 코드를 자식 클래스에서 재사용할 수 있다. 그러나 보통 상속을 사용시 처음부터 상속을 염두해두고, 상속 계층 사이에 많은 가정이 존재할 수 있다. 이 가정은 부모 클래스를 만든 개발자가 알 것이다. 만약 자식 클래스를 추가하여 이 부모 클래스를 사용하게 된다면, 자식, 클래스를 만든 개발자는 부모 클래스를 만든 개발자의 가정을 정확히 이해하고 있어야 한다. 또한 요구사항과 구현 사이의 차이가 커질 수 있는데, 그럴 수록 코드를 이해하고 재사용하기 어려워진다. 따라서 상속을 사용 시에는 제대로 사용하지 않으면 높은 결합도를 가질 수 있으니 조심하자.

##### 강하게 결합된 부모 - 자식 관계
- 예를 들어 부모 클래스에 선언된 메소드를 자식 클래스에서 super().메소드()로 참조하고 있다고 가정해보자. 그런데 새로운 정책이 생겨 새로운 로직이 추가되었을 때, 자식 클래스는 의도와는 다른 값을 받아 사용하게 될 수 있다. 부모 클래스의 메소드를 직접 호출 할 경우 두 클래스는 강하게 결합된다.
- 따라서 상속 사용 시 부모 클래스를 참조하여 자식 클래스를 점진적으로 기능을 추가하여 확장하는 데 용이하지만, 높은 결합도로 인해 부모 클래스의 기능을 개선하는 것은 어렵다.
- 상속받은 부모 클래스의 메서드가 자식 클래스 내부 구조에 대한 규칙을 깨트릴 수 있다.
- 자식 클래스 오버라이딩 시 부모 메서드에 자식 클래스가 결합될 수 있다. -> 의도와는 다른 값이 나올 수 있다.
- 조슈아 블로치는 클래스가 상속되기를 원한다면 상속을 위해 클래스를 설계하고, 문서화해야 하며 그렇지 않은 경우 상속을 금지시켜야 한다고 주장한다. 그러나 상속의 내부 구현을 문서화하는 것은 캡슐화를 위반한다. 상속은 코드 재사용을 위해 캡슐화를 희상시키는 트레이도오프의 선택이 필요하다.
- 상속 사용 시 결합도로 인해 자식과 부모의 구현을 영원히 변경하지 않거나, 자식과 부모를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.

##### 상속 도입 시 고려할 두 가지 원칙
- 무 메서드가 유사해보인다면, 차이점을 메서드로 추출, 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
    - 중복 코드에서 차이점을 별도의 메서드로 추출
- 부모 클래스 코드를 하위로 내리지 말고, 자식 클래스의 코드를 상위로 올려라.즉, 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과
    - 두 클래스 모두 사용하는 중복 클래스는 하나로 빼고, 차이점을 추상화로 만들어 각 자식마다 이를 오버라이딩하여 사용한다.
    <br/>
- 결론: 자식 클래스 사이의 공통점을 부모로 옮기면서 실제 코드를 기반으로 상속 계층 구성 가능

#### 결로오오온
- 객체지향을 더 알고 나면 코드의 재사용을 위해 상속을 사용하는 것은 위험하다는 것을 알게 된다. 강력한 만큼 제대로 된 설계로 시작하지 않으면 그만큼 피해가 크다. 이런 상속의 단점을 피하면서도 코드의 재사용성을 하기 좋은 방법이 바로 합성(포함)이다.
    
    

