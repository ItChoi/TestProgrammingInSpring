### 메시지와 인터페이스
- 객체지향 프로그래밍에서는 애플리케이션이 클래스의 집합으로 구성되는 것이 아니다. 따라서 너무 클래스에 초점을 두어 설계를 하면 안된다. 협력 안에서 객체의 책임에 초점을 두어 클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 두어야 한다. 애플리케이션은 클래스를 통해 구성되지만, 메시지를 통해 정의된다는 사실을 기억해야 한다.
- 객체가 수신하는 메시지들은 퍼블릭 인터페이스로 구성한다. 퍼블릭 인터페이스는 책임 주도 설계 방법 뿐만 아니라, 설계 원칙과 깁법을 익히고 적용해야 한다.

#### 협력과 메시지
- 클라이언트-서버 모델
    - 객체는 협력에 참여하는 동안 클라이언트아 서버의 역할을 동시에 수행하는 것이 일반적이다. 협력에 적합한 객체를 설계하기 위해서는 객체가 수신하는 메시지 뿐만 아니라 외부에 전송할 메시지도 함께 고려해야 한다.
    <br/>
    
- 메시지와 메시지 전송
    - UML 용어로, 인터페이스의 각 요소는 오퍼레이션이다.
    - 오퍼레이션(메시지) 이름과 파라미터 목록을 합쳐 시그니처라고 부른다.
    - 메시지 전송 시 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 메시지 수신 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다. 즉, 클라이언트에서 메시지 전송 시 오퍼레이션을 호출하고, 서버에서 오퍼레이션의 실제 구현체를 찾아 메서드를 실행시킨다.
            
            
#### 인터페이스와 설계 품질
- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스다. 따라서 초점을 둘 때, 어떻게 수행하는지가 아니라 무엇을 하는지 표현하고 메시지를 먼저 선택하고 메시지가 객체를 선택하게 해야 한다.
- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
    - 디미터 법칙
      - 협력하는 객체의 내부 구조에 대한 높은 결합도로 코드 변경으로 인한 변경이 필요한 것을 해결하기 위해 제안된 원칙이다.
      - 낯선자에게 말하지 말라, 오직 인접한 이웃하고만 말하라, 도트를 사용하는 언어(.)에서는 오직 하나의 도트만 사용하라는 말로 요약된다.
      - 캡슐화를 다른 관점에서 표현하며 클래스를 캡슐화하기 위해 따라야 하는 구체적인 지침을 제공
      - 캡슐화 원칙이 클래스 내부 구현을 감춰야 한다는 사실을 강조한다면, 디미터 법칙은 협력하는 캘르스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다.
      - 객체의 내부 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지가 더 좋은 메시지라고 본다.
        - 나쁜 예) screening.getMovie().getDiscountConditions();
        = 좋은 예)  screening.calculateFee(audienceCount);
      <br/>
      
    - 묻지 말고 시켜라
        - 메시지는 객체의 상태를 묻지 않고 원하는 것을 시켜야 한다. 메시지 전송자는 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안된다.
        - 이를 따르면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도와 퍼블릭 인터페이스의 품질을 향상시킬 수 있다.
        - 묻지 말고 시켜라 뿐만 아니라, 객체가 어떻게 작업을 수행하는 지 노출하지 않고 무엇을 하는지 서술해야 한다.
    <br/>
    
    - 의도를 드러내는 인터페이스
        - 어떻게 수행할 지에 대해 언급하지 말고 결과와 목적만을 포함하도록 클래스와 오퍼레이션의 이름을 부여
        - 오퍼레이션 이름은 협력을 반영하여 클라이언트가 무엇을 원하는 지 의도를 표현하는 이름을 가져야 한다.
    <br/>
    
    - 명령-쿼리 분리
    
#### 원칙의 함정
- 디미터 법칙은 하나의 도트(.)를 하나만 쓰도록 강제하진 않는다. 즉 같은 클래스의 내부 구조가 외부로 노출되지 않는다면 사용 가능하다.
- 로버트 마틴은 클린 코드란 책에서 디미터 법칙은 그 대상이 겍체인지 자료 구조인지에 따라 적용 여부가 다르다고 한다. 객체의 경우 내부 구조를 노출하면 안되므로 디미터 법칙을 따르지만, 자료 구조의 경우 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.

#### 명령-쿼리 분리 원칙
- 루틴: 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈, 루틴은 프로시저와 함수로 구분 가능하다.
- 프로시저:정해진 절차에 따라 내부의 상태를 변경 (반환 값x)
- 함수: 어떤 절차에 따라 필요한 값을 계산하여 반환
    <br/>
    
- 명령: 객체의 상태 변경 (반환 값 x)
- 쿼리: 객체와 관련된 정보 반환 
    <br/>
    
- 오퍼레이션은 명령이거나 쿼리여야 한다. 두 가지가 공존할 수 없다.
    <br/>
    
- 도메인 두 가지 용어
    - 이벤트: 특정 일자에 실제로 발생하는 사건
    - 반복 일정: 특정 단위로 돌아오는 특정 시간 간격에 발생하는 사건 전체를 포괄적으로 지칭
    <br/>
    
- 명령과 쿼리 두 가지 역할을 하는 경우 가독성이 떨어져 버그를 양산할 수 있고 버그를 찾기도 어렵다. 개발자 혼자 개발하는 것이 아닌, 다수의 개발자가 요구사항 추가에 따라 하나의 메서드에 다양한 코드를 넣어 명령과 쿼리의 두 가지 역할을 하는 메소드를 만들어 놓으면 아주 큰일난다. 따라서 명령과 쿼리를 명확하게 분리해야 한다.
    <br/>
    

    