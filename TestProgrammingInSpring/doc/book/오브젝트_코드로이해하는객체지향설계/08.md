### 의존성 관리하기
- 애플리케이션의 기능을 구현하기 위해서 협력은 필수적이지만, 과도한 협력은 설계를 곤경에 빠뜨릴 수 있다.

#### 의존성 이해하기
- 변경과 의존성
    - 객체가 다른 객체를 참조할 때 의존성이 생겨난다. 이 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 갖는다.
      - 실행 시점
        - 실행 시 의존 대상 객체가 반드시 존재해야 한다.
      - 구현 시점
        - 의존 대상 객체 변경 시 의존하는 객체도 함께 변경
    - 의존성은 단방향을 갖는다. A가 B를 참조할 경우 B의 변경이 A에 영향을 주지만, A 변경으로 B는 영향을 받지 않는다.
    - 의존성은 변경에 의해 영향을 받는지 여부를 암시할 수 있다.
    <br/>
    
- 의존성 전이
    - A가 B를 의존하고 B가 C를 의존할 경우 C의 변경으로 A에게 변경의 영향이 전이될 수 있다. 따라서 B의 내부 구현을 효과적으로 캡슐화한다면, 의존성 전이가 되지 않을 수 있다.
    - 의존성 종류
      - 직접 의존성(direct dependency): 의존 관계를 직접적으로 맺고 있는 것
      - 간접 의존성(indirect dependency): 의존 관계를 직접적으로 맺지는 않으나, 의존성 전이에 의해 영향을 받을 수 있는 것
    <br/>
    
- 런타임 의존성과 컴파일타임 의존성
    - 런타임: 애플리케이션이 실행되는 시점
      - 객체지향 App에서 런타임의 주인공은 객체라서, 런타임 의존성은 객체 사이의 의존성이다.
    - 컴파일타임: 작성된 코드를 컴파일 하는 시점 또는 문맥에 따라 코드 그 자체를 가리키기도 한다.
      - 코드 관점에서 주인공은 클래스다. 따라서 컴파일 타임이 다루는 주제는 클래스 사이의 의존성이다.
    - 예를 들어 코드 시점에는 영화가 금액 할인인지, 퍼센트 할인인지 전혀 알지 못하지만, 실행 시점에 영화는 금액 할인 또는 퍼센트 할인과 협력할 수 있어야 한다.
    - 어떤 인스턴스가 다양한 인스턴스와 협력하기 위해서는 구체적인 협력 인스턴스를 알아서는 안된다. 구체적인 협력 인스턴스를 알아내는 건 런타임에 해결해야 한다. 따라서 컴파일 구조와 런타임 구조 사이의 거리가 멀면 멀 수록 설계가 유연해지고 재사용 가능해진다.
    - 컴파일 의존성 -> 런타임 의존성 교체 3가지 방법
      - 가장 선호 방식은 생성자 + setter 혼합 방식이다. 안정적 유지 + 유연성 향상
      - 생성자
      - setter
        - 객체 생성 이후에도 객체 변경 가능
      - 매개변수
        - 메소드 실행시에만 실행 또는 객체 대상이 매번 달라져야 하는 경우 유용
        
#### 유연한 설계
- 명시적 의존성
    - 퍼블릭 인터페이스에 인자를 사용하는 경우 명시적인 의존성이라 한다. 반면, 내부에서 인스턴스를 직접 생성하는 방식을 숨겨진 의존성이라 하는데, 의존성은 명시적으로 표현돼야 한다. 의존성을 내부 구현에 숨기면 안된다. 그래야 퍼블릭 인터페이스를 통해 컴파일 타임 의존성이 적절한 런타임 의존성으로 교체할 수 있다.
    <br/>
    
- new는 해롭다.
    - 구체 클래스의 이름을 직접 기술하기 때문에 구체 클래스에 의존할 수 밖에 없어서 결합도가 높아진다.
    - 생성자의 인자도 알아야 하기 떄문에 사용자가 알아야 하는 지식의 양이 늘어나 결합도가 높아진다.
    <br/>
    
- 표준 클래스에 대한 의존은 해롭지 않다.
    - 의존성은 항상 변경에 대햔 영향을 암시한다. 따라서 변경될 확률이 거의 없는 클래스는 의존성이 문제되지 않는다.
    <br/>
    
- 객체 확장
    - 매개 변수가 null인지 체크하는 로직을 넣었다. 이는 문제가 있다. 어떤 경우든 내부 코드를 직접 수정하는 것은 버그 발생 가능성을 높인다. 따라서 존재하지 않는 사실을 예외 케이스 처리로 하지 말고 존재하지 않는다는 사실을 하나의 종류로 클래스를 추가하는 것이다.
    - 하나의 정책을 사용하던 방식이, 여러 개의 정책을 중복으로 사용하는 방식도 생겼다. 이 경우 복수 정책 사용 방식을 하나의 클래스로 만들어 하나의 정책 클래스를 상속받아 자식으로 만든다.

        
        
    