### 객체, 설계
- 이론이 먼저일까? 실무가 먼저일까?
    - 처음 배울 시기에는 흐름이 잡혀있지 않기 때문에 이론을 적립할 수 없는 초기에는 실무가 급속한 발전을 이룬다고 한다. 그 다음에 실무의 실용성을 입증할 수 있는 이론을 적립하는 것이 좋다. 즉, 초반에는 이론이 실무보다 급속한 성장을 이루지만, 실무가 익숙해지고 어느 정도 가닥이 잡히고 나면, 그 후에는 이론이 실무를 추월한다고 본다.
    <br/>
    
    - 특히 이론보다 실무가 앞서 있는 것은 '소프트웨어 설계'와 '소프트웨어 유지보수'이다. 보통의 경우 설계의 이론을 쌓고 이론을 바탕으로 실무에서의 설계나 패턴 등이 정해지는 것 보단, 실무를 경험하고 익숙해지면서 효율적인 설계나 패턴을 이론으로 적립하는 경우가 대부분이라고 한다.
    <br/>
    
    - 결론적으로 '소프트웨어 설계'는 실무 위주로 ! 코드 위주로 배우고 혼자 고민하여 여러 가지 상황을 만들어 설계해보는 것이 필요한 거 같다.
    <br/>
    
#### 01 티켓 판매 애플리케이션 구현하기.
- 상황
    - 소극장 경영중
    - 이벤트 기획 - 무료 초대장 발송
    - 관람객, 당첨자 구분
    - 다른 방식 입장 (티켓으로 교환, 구매)
    <br/>
    - 관람객은 가방이 있다고 가정!
    <br/>

- 로직
    - 소극장은 관람객 가방 안에 초대장 유무 확인
    - 당첨자가 아니라면 티켓 구매해야 한다.
    - 가방에서 티켓 금액 차감 후 매표소 금액증가
    - 가방안에 티켓 넣어줌
    <br/>

##### 무엇이 문제인가?
- 소프트웨어 모듈이 가져야하는 세 가지 기능
    - 모듈은 크기와 상관없이 패키지나 클래스, 라이브러리와 같이 프로그램을 구성하는 것을 의미.
    - 기능(1). 실행 중 제대로 동작 
      - 모듈의 존재 이유
    - 기능(2). 변경을 위해 존재
      - 대부분의 모듈은 생명주기 동안 변경 작업이 일어나기 때문에 쉽게 변경 가능해야함.
      - 결합도를 줄이고 중복 코드 개선..
    - 기능(3). 다른 개발자가 코드로 의사소통이 가능하도록..
      - 코드를 쉽게 이해하고 읽을 수 있게 해야한다.
      <br/>
      
- 위에 코드들은 기능(1)은 만족하지만, 아쉽게 기능(2)와 기능(3)을 만족시키진 못한다.
    - 원인
      - 클래스가 각자의 역할에 충실하지 못하다. 예를 들어 돈을 가방에 꺼내어 매표소에 지불하는 것은 관람객의 역할, 티켓을 뽑아 관람객에게 건내고 돈을 넣는 것은 직원의 역할이다. 그렇지 못하기에 이 코드를 이해하기 어렵다.
      - 하나의 클래스나 메서드에 많은 내용이 담겨 있어 모든 사실을 기억하기 어렵다.
      - 하나의 클래스를 변경하면, 이 클래스를 참조하고 있던 코드도 같이 변경해 불필요한 작업이 생겨난다.   
        - 객체 사이의 의존성(dependency)을 완전히 없애는 것은 정답이 아니다. 따라서 최소한의 의존성만을 유지하는 것이 중요하다.
        <br/>
        
- 해결!!!
    - 관람객과 판매원의 역할을 극장이 알아야 할 필요가 없다. 극장은 단지 관람객을 입장시키기만 하면 된다. 
    - 관람객의 역할, 판매원의 역할을 구분하여 자율적인 존재로 만들자!
    <br/>
    
    - 1단계: Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨기는 것이다.
      - TicketSeller에 sellTo 메서드 추가하고, Theater에 있던 로직을 이 메서드로 옮기자.
      <br/>
      
    - 2단계: 관람객의 bag에 접근하는 것은 직원이 아니라 본인이어야 한다. 캡슐화를 해보자. 
      - Bag에 접근하는 모든 로직을 Audience로 숨기기 위해 buy 메서드 추가
      - TicketSeller의 sellTo 메서드에서 getBag() 접근 부분을 buy 메서드로 옮기자.
      <br/>
      
    - 3단계: 관람객은 스스로 Bag에서 티켓을 확인하고, 직원은 Audience의 인터페이스에만 의존하도록 해보자.
      - TicketSellet가 buy 메서드를 호출하도록 변경!
      

- 개선된 점
    - 관람객과 직원은 내부 구현을 외부에 노출하지 않고 역할에 책임을 가졌다.
    - 관람객이나 직원의 코드가 변경되도 극장의 코드를 변경할 필요가 없다.
    - 객체의 자율성을 높임으로써 이해하기 쉽고 유연한 설계를 얻었다.    
    <br/>
    
- 캡슐화와 응집도
    - 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해 상호작용하도록 하는것
    - 객체는 본인과 연관된 작업만을 수행하는 자율적인 존재여야 하고, 연관성 없는 작업은 다른 객체에게 작업을 위임
    - 응집도는 객체 간에 의존성이 낮은걸 말하는데, 하나의 객체를 바꿀 때 다른 객체의 수정도 필요하게 되는 것이 결합도가 높다고 하는데, 그 반대의 개념이다.
    - 외부의 간섭은 최대한 배제하는 것이 좋다.

#### 절차지향과 객체지향
- 절차적 프로그래밍
    - 프로세스와 데이터를 별도의 모듈로 위치시키는 방식이다. 위에 살펴본 첫 예제는 모든 처리가 하나의 클래스(극장)에 존재하고, 나머지 클래스(관람객, 판매자, 가방 등)는 단지 데이터 역할만 수행한다. 따라서 절차적 프로그래밍은 우리의 직관을 위배한다. 즉 우리의 예상을 벗어날 확률이 높기 떄문에 코드를 읽는 사람이 난해할 수 있다.  
    - 결합도가 높을 확률이 있기 때문에 데이터 변경으로 인한 영향을 지역적으로 고립시키기 어렵다. 변경은 버그를 부르기 때문에 악영향 가능성이 있다.
    - 절차적 프로그래밍은 프로세스가 필요한 모든 데이터에 의존해야 한다는 근본적인 문제점때문에 변경에 취약하다.
      - 언젠간 알게되겠지 궁금증...
        - 절차적 프로그래밍의 근본적인 문제는 절차적 프로그래밍을 접한 주니어급 개발자들에게만 해당할까? 절차적 프로그래밍의 전문가들은 이러한 근본적인 문제점을 어떻게 극복할까? 극복하기 위해 코드를 지저분하게 하는 것이 아닌, 절차적 프로그래밍의 장점을 살리면서 근본적인 문제를 피해갈 수 있을까? ....하하핳
    <br/>
    
- 객체지향 프로그래밍
    - 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 하는 것
    - 의존성을 적절히 통제 - 하나의 변경으로 인해 공수가 늘어나는 것을 효율적으로 억제
    - 객체지향 설계의 핵심 -> 캡슐화! -> 캡슐화를 통해 의존성을 적절히 관리함으로써 결합도를 낮출 수 있다.
    - 객체는 다른 객체와 협력 관계에서의 특정한 역할을 수행한다.
    - 객체가 갖는 데이터가 아닌, 객체에 어떤 책임을 할당할 것인가에 초점을 두어야 한다.
    - **적절한 객체에 적절한 책임을 할당하면 이해하기 쉽고 읽기 쉬운 코드가 된다.**
    
#### 극장 예제 더 개선 가능!
- Bag은 자기 역할에 책임지지 않고 Audience에 끌려다니는 수동적인 존재로 되어 있다. 코드를 개선해보자.
- 코드로 보기..
- 결론: 특정 상황에서는 결합도를 낮출지, 자율성을 높일 지 선택을 해야하는 트레이드오프 시점이 온다. 어떤 설계든 모든 사람을 만족시키지 못하기 때문에, 적절한 상황에 맞는 효율적인 설계를 위해 트레이드오프시점에 균형을 맞추어야 한다.

#### 객체지향의 시점
- **예제에서 가방이나, 티켓의 경우 현실 세계에서는 능동적인 존재가 아닌 수동적인 존재다. 하지만 객체지향 관점에서는 모든 것이 능동적이고 자율적인 존재로 무생물 역시 스스로 행동하고 자기 자신을 책임지는 자율적인 존재로 취급해야 한다.**

#### 객체지향 설계
- 설계가 왜 필요할까?
    - 설계의 정의: 설계란 코드를 배치하는 것이다.
    - 설계와 구현은 하나로 묶어 생각하자.
    - 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용하는 것이다. 왜냐하면 요구사항은 매번 바뀌고 개발 시작 시점에 구현에 필요한 모든 요구사항을 수집하는 것은 불가능하다.
    - 변경을 수용하는 설계가 중요한 이유는, 코드 변경 시 버그 추가 가능성과, 이로인한 코드 수정의 두려움이 생긴다.
    
    
