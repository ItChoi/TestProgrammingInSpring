### 유연한 설계

#### 개방-폐쇄 원칙 (Open-Closed Principle)
- 확장 가능하고 변화에 유연한 설계를 만들 수 있는 원칙 중 하나
- 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀있어야 한다.
    - 컴파일 타임 시 의존성을 고정하고, 런타임 의존성을 변경하라. 예를 들어 다형성에서 할인이라는 인터페이스는 여러 가지 종류의 할인을 구체화 한다. 여기서 컴파일 시에는 할인을 의존하지만, 런타임 시 할인의 구체 클래스가 정해지는 것을 통해 OCP를 이해할 수 있다. 즉, 추상화에 의존한다.
- 변하는 부분 고정, 변하지 않는 부분 생략 -> 변하는 부분은 추상화를 사용하여 구체적인 구현을 따로 두고, 변하지 않는 부분은 코드를 사용한다.
- 단순히 추상화를 사용했다고 해서 OCP를 가능하게 하지 않는다. 중요한 것은 의존성의 방향이다.
- 변경에 의한 공수를 최대한 줄이기 위해서는 변하는 것과 변하지 않는 것을 이해하고 추상화의 목적으로 삼아야 한다.

#### 생성 사용 분리
- 유연하고 재사용 가능한 설계를 위함.
- 무비는 할인 정책이라는 추상화에 의존한다. 무비 내부에서 할인 정책의 생성과 사용을 동시에 하면 안된다. 동일한 클래스 내에서 객체의 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하는 것은 문제다.
- 소프트웨어 시스템은 시작 단계와 실행단계를 분리해야 한다.
- 생성과 사용을 분리하는 가장 일반적인 방법은, 객체의 생성을 클라이언트로 옮기는 것이다.
- 생성과 사용을 분리하기 위해 객체 생성 책임의 특화된 객체를 Factory라 부른다.
    - 도메인 모델에 속하지 않는 것
    - Factory 추가 이유는 기술적인 결정
    - 객체 책임 할당으로는 도메인을표현하기 부족한 경우 사용
    - DB 접근 등 도메인 개념들을초월한 기계적인 개념 필요 시 사용
    - 도메인과 무관한 인공적인 객체를 크레이그 라만은 PURE FABRICATION(순수한 가공 공물)이라 부른다.
    - 추상화를 이용하여 애플리케이션 구축을 시작하고, 도메인 개념이 만족스럽지 못하다면 인공적인 객체를 만들자.
    - 대부분 디자인 패턴은 PURE FABRICATION을 포함한다.

#### 의존성 주입 (Dependency Injection)
- 외부에서 독립적인 객체가 인스턴스 생성 후 이를 서비스에서 사용할 수 있다.
- DI 외에 의존성을 해결할 수 있는 다양한 방법들이 존재한다. 그 중 대표적으로 SERVICE LOCATION 패턴이있다. 
- SERVICE LOCATOR 패턴
    - 객체가 직접 SERVICE LOCATOR에게 의존성을 해결해줄 것을요청
    - 저자는 개인적으로 선호하지 않는 패턴, 의존성을 감추기 때문
    - 의존성을 숨길 시 테스트 코드 작성도 어렵다. (상태 공유)
- 가급적 의존성은 객체의 퍼블릭 인터페이스에 노출하자. 그래야 코드를 이해하고 수정하기 쉬워진다.
- 의존성 역전 원칙
    - 추상화에 의존해라.
    - 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안되고, 둘 다 추상화에 의존해야 한다.
    - 추상화는 구체적인 내부 클래스에 의존하면 안되고, 구체적인 사항은 추상화에 의존!
    - 영화가 퍼블릭 인터페이스와 구체 클래스들을 같은 패지키에 뒀을 때, 이를 배포 시 사용자, 퍼블릭인터페이스, 구체 클래스를 같은패키지에 둬서 비효율적인 재컴파일이 일어날 수 있다. 따라서 사용자와 퍼블릭 인터페이스는 참조하기에 같은 패키지에 두고, 구체 클래스는 별도의 패키지에 두어야 한다.

#### 유연성에 대한 조언
- 유연하고 재사용 가능한 설계까 항상 좋은 것은 아니다. 설계의 미덕은 단순함과 명확함인데, 유연한 설계는 복잡한 설계라는 의미가 숨어 있다.
- 핵심은 객체 생성하는 방법에 대한 결정은 모든 책임을 먼저 결정 후 가장 마지막에 내리는 것이 적절하다.
    
   
   
