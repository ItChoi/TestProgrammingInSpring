### 설계 품질과 트레이드 오프
- "이 객체에 포함해야 하는 데이터가 무엇인가?"라고 생각하고 있다면 데이터 중심의 설계로 하고 있응 확률이 높다.
    - 메시지 -> 객체 -> 상태
    <br/>
    
#### 설계 트레이드 오프
- 데이터 중심 설계 vs 책임 중심 설계 (비교를 위해 캡슐화, 응집도, 결합도 사용)
    - 캡슐화
      - 변경될 가능성이 높은 부분을 구현이라 하고, 상대적으로 안정적인 부분을 인터페이스라고 한다. 객체를 설계하기 위해 변경의 정도에 따라 구현과 인터페이스를 분리하고, 외부에서는 인터페이스에만 의존하도록 관계를 조절해야 한다. 
      - 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리하여 변경의 영향을 통제할 수 있다.
      - 나의 생각은, private으로 아무리 숨겨도, 외부에서 사용시 불필요하게 객체가 타 객체의 행동이나 상태를 알 필요가 없으니, 책임 중심으로 하여 외부에서 내부 상태나 행동을 숨기는 것이 필요하다... 인 것 같다....
    <br/>
    
    - 응집도
      - 객체지향 설계의 관점에서 객체마다 적절한 책임을 할당했을 때 응집도가 높아진다.
    - 결합도
      - 객체 간의 의존성 정도를 나타낸다.
    <br/>

- 데이터 중심 설계의 문제점
    - 캡슐화 위반
      - private으로 감춘다고 캡슐화가 되는 것은 아니다. 예를 들어 Movie 클래스에 요금을 받을 때 접근자(getter), 수정자(setter)를 통해 내부에 Money 타입의 fee 라는 이름의 인스턴스 변수가 존재한다는 사실을 public 인터페이스에 노골적으로 드러낸다.
      - 설계할 때 협력에 관한 고민을 하지 않으면, 캡슐화를 위반하는 접근자와 수정자를 과도하게 사용하게 될 수 있다. 이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략이라고 부른다. 이는 객체 간의 협력을 고려하지 않고 막연한 추측을 기반으로 설계를 진행한다.
      - 파라미터를 통해 외부에 어떤 타입을 파라미터로 받는지 공개하지 않아도, 메서드의 종류를 통해, 예를 들어 할인 정책에 None, Percent, Amount 정책을 사용하는지 외부에서 확인할 수 있다. 데이터 중심 설계를 하면 이런 문제점이 있다.
      - 캡슐화란 변하는 어떤 것이든 감추는 것이다. 그것이 무엇이든 구현과 관련된 것이라면 감추어야 한다.
      <br/>
      
    - 높은 결합도
    - 낮은 응집도
    - 단일 책임 원칙(Single Responsibility Principle): 모듈의 응집도가 변경과 연관이 있다는 사실 강조, 클래스는 단 한 가지의 변경 이유만 가져야 한다. 
    <br/>
    
    - 데이터 중심의 설계가 변경에 취약한 이유
      - 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
        - 데이터는 구현의 일부이다. 따라서 너무 이른 시기에 내부 구현에 초점을 맞추어 데이터를 미리 결정하면 안된다.
        - 데이터 처리 작업과 데이터를 같은 객체지향적으로, 객체 안에 두더라도 데이터에 초점을 맞춘다면 캡슐화가 되기 어렵다.
    <br/>
    
      - 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 메서드를 결정한다.
        - 객체 간의 협력 안에서 필요한 책임을 결정하고, 이를 수행할 객체를 결정해야 한다.
        - 객체 지향 설계의 무게는, 내부가 아닌 외부에 맞추어야 한다.
        - 객체가 내부 상태로 어떻게 동작하게 만들 것인가는 부가적인 문제고, 객체와 객체의 협력을 중요시해야 한다.
       
    
      
    