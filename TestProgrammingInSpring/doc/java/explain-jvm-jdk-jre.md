### JVM, JDK, JRE의 이해
##### 1. JVM
  - 자바 바이트 코드를 어떻게 실행할지에 대한 표준 스펙
  - 바이트 코드 실행 시 인터프리터나, git compile 등을 사용하여 os에 특화된 코드로 변환 
  - 플랫폼에 종속적이다.
  - 최초 JVM은 자바만 지원하기 위해 만들어졌으나, 자바와 의존성이 타이트하지 않아, 타 언어로 컴파일 시 클래스 파일이나 자바 파일을 만들어준다면 JVM을 활용할 수 있다.
  
  
  - JVM 구조
    - 몇 가지 component로 구성되어 있다. (5가지)
        1. 클래스 로더 (로딩, 링크, 초기화)
          - 바이트 코드를 디컴파일하여 사람이 읽을 수 있게 변환. (.class에서 바이트 코드를 읽고 메모리에 저장)
          <br/>
          
          - 로딩: Bootstrap(부트 스트랩 클래스 로더), Extension(요즘은 플랫폼 클래스 로더라 함), Application(애플리케이션 클래스 로더)
          - 로딩: 클래스 로더를 통해 .class에 있는 바이너리 코드들을 읽어 메소드 영역에 데이터를 저장한다. 그리고 로딩이 끝나면 Class 객체를 생성하여 힙 영역에 저장한다.
          <br/>
          
          - 링크: Verify, Prepare, Resolve - 
          - 링크: .class 파일이 유효한지 체크하고, 기본 값에 필요한 메모리를 준비한 후, 논리적 reference를 heap에 있는 객체를 가리키도록 한다.(선택적)
          <br/>
          
          - 초기화: initialization
          - 초기화: 메모리 영역에 스태틱 값을 할당.
          <br/>
          
        2. 메모리 (스택, PC, 네이티브 메소드 스택, 힙, 메소드)
            - 메소드 영역에서는 패키지 포함한 클래스, 상속을 포함하여 클래스 수준의 정보(메소드 포함)들을 저장한다고 보면 된다.
            - 힙 영역에서는 객체를 관리한다.
            - 메소드 영역과 힙 영역은 다른 영역에서도 공유가 가능하다.
            - 나머지는 스레드에 국한되며 어떤 스레드냐에 따라 그 스레드에서만 공유하는 자원이다.
            - 스택은 스레드 마다 런타임 스택이란 것을 만들고 그 안에 스택 프레임을 쌓는데, 스텍 프레임이란 메서드 콜이다. 
            - 만들어진 스택에 메서드를 쌓았는데, 현재 어느 위치를 실행하고 있는지 가르키는 pc register가 생긴다. (스레드 마다 생긴다.)
            - 네이티브 메소드 스택 reference: [https://javapapers.com/core-java/java-jvm-run-time-data-areas/#Program_Counter_PC_Register](https://javapapers.com/core-java/java-jvm-run-time-data-areas/#Program_Counter_PC_Register)
            - % native method: 네이티브 메소드는 메서드에 native 키워드가 붙어있고 그 구현을 java가 아닌 c나 c++로 구현한 것.
            - % JIT(Just in time?) 컴파일러: 인터프리터 효율을 높이기 위해 반복되는 코드를 모두 네이티브 코드로 바꿔둔다. 그리고 인터프리터는 컴파일된(jit) 코드를 바로 사용한다.
        3. 실행 엔진 (인터프리터, JIT 컴파일러, GC)
        <br/>
        
    - 클래스 로더
         
              
##### 2. JDK
  - 자바 11부터는 JDK만 제공... (JDK / JRE 구분 X) 

##### 3. JRE
  - 자바 애플리케이션을 실행하기 위한 것 JRE 안에는 JVM 및 Library가 들어있다.
